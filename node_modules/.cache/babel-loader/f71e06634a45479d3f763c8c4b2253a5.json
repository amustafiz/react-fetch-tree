{"ast":null,"code":"import { Component } from 'react';\nimport { parse } from 'css-what';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\nfunction __generator(thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n}\n\nfunction __values(o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n      i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n}\n\nfunction __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n}\n\nfunction __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n\n  return ar;\n}\n\nfunction traverseGenerator(node, _a) {\n  function traverseSelf() {\n    var controlInput;\n\n    var _a, _b;\n\n    return __generator(this, function (_c) {\n      switch (_c.label) {\n        case 0:\n          if (!!skipSelf) return [3, 2];\n          return [4, node];\n\n        case 1:\n          controlInput = _c.sent();\n\n          if (controlInput !== undefined) {\n            _a = controlInput.skipChild, skipChild = _a === void 0 ? skipChild : _a, _b = controlInput.skipSibling, skipSibling = _b === void 0 ? skipSibling : _b;\n          }\n\n          _c.label = 2;\n\n        case 2:\n          return [2];\n      }\n    });\n  }\n\n  function traverseChild() {\n    var nextNode;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          if (!(!skipChild && node.child !== null)) return [3, 2];\n          nextNode = node.child;\n          return [5, __values(traverseGenerator(nextNode, {\n            order: order,\n            skipSiblingForStartNode: false,\n            skipSelfForStartNode: false\n          }))];\n\n        case 1:\n          _a.sent();\n\n          _a.label = 2;\n\n        case 2:\n          return [2];\n      }\n    });\n  }\n\n  function traverseSibling() {\n    var nextNode;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          if (!(!skipSibling && node.sibling !== null)) return [3, 2];\n          nextNode = node.sibling;\n          return [5, __values(traverseGenerator(nextNode, {\n            order: order,\n            skipSiblingForStartNode: false,\n            skipSelfForStartNode: false\n          }))];\n\n        case 1:\n          _a.sent();\n\n          _a.label = 2;\n\n        case 2:\n          return [2];\n      }\n    });\n  }\n\n  var skipChild, skipSibling, skipSelf, traverseMap, orderedGenerators, orderedGenerators_1, orderedGenerators_1_1, eachGen, e_1_1;\n\n  var e_1, _b;\n\n  var _c = _a === void 0 ? {} : _a,\n      _d = _c.order,\n      order = _d === void 0 ? [\"self\", \"child\", \"sibling\"] : _d,\n      _e = _c.skipSiblingForStartNode,\n      skipSiblingForStartNode = _e === void 0 ? true : _e,\n      _f = _c.skipSelfForStartNode,\n      skipSelfForStartNode = _f === void 0 ? false : _f;\n\n  return __generator(this, function (_g) {\n    switch (_g.label) {\n      case 0:\n        skipChild = false, skipSibling = skipSiblingForStartNode, skipSelf = skipSelfForStartNode;\n        traverseMap = {\n          self: traverseSelf,\n          child: traverseChild,\n          sibling: traverseSibling\n        };\n        orderedGenerators = order.map(function (step) {\n          return traverseMap[step];\n        }).filter(function (tmp) {\n          return tmp !== undefined;\n        });\n        _g.label = 1;\n\n      case 1:\n        _g.trys.push([1, 6, 7, 8]);\n\n        orderedGenerators_1 = __values(orderedGenerators), orderedGenerators_1_1 = orderedGenerators_1.next();\n        _g.label = 2;\n\n      case 2:\n        if (!!orderedGenerators_1_1.done) return [3, 5];\n        eachGen = orderedGenerators_1_1.value;\n        return [5, __values(eachGen())];\n\n      case 3:\n        _g.sent();\n\n        _g.label = 4;\n\n      case 4:\n        orderedGenerators_1_1 = orderedGenerators_1.next();\n        return [3, 2];\n\n      case 5:\n        return [3, 8];\n\n      case 6:\n        e_1_1 = _g.sent();\n        e_1 = {\n          error: e_1_1\n        };\n        return [3, 8];\n\n      case 7:\n        try {\n          if (orderedGenerators_1_1 && !orderedGenerators_1_1.done && (_b = orderedGenerators_1[\"return\"])) _b.call(orderedGenerators_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n\n        return [7];\n\n      case 8:\n        return [2];\n    }\n  });\n}\n\nfunction traverse(node, fn, traverseConfig) {\n  var e_2, _a;\n\n  var nodeIterator = traverseGenerator(node, traverseConfig);\n\n  try {\n    for (var nodeIterator_1 = __values(nodeIterator), nodeIterator_1_1 = nodeIterator_1.next(); !nodeIterator_1_1.done; nodeIterator_1_1 = nodeIterator_1.next()) {\n      var tmpNode = nodeIterator_1_1.value;\n      fn.call(null, tmpNode);\n    }\n  } catch (e_2_1) {\n    e_2 = {\n      error: e_2_1\n    };\n  } finally {\n    try {\n      if (nodeIterator_1_1 && !nodeIterator_1_1.done && (_a = nodeIterator_1[\"return\"])) _a.call(nodeIterator_1);\n    } finally {\n      if (e_2) throw e_2.error;\n    }\n  }\n}\n\nfunction isNodeHtmlLike(node) {\n  return typeof node.type === \"string\" || node.type === null;\n}\n\nfunction isNodeNotHtmlLike(node) {\n  return !isNodeHtmlLike(node);\n}\n\nfunction isNodeFunctionComponent(node) {\n  return isNodeNotHtmlLike(node) && node.stateNode === null;\n}\n\nfunction isNodeComponentClass(node) {\n  return isNodeNotHtmlLike(node) && node.stateNode instanceof Component;\n}\n\nfunction isConstructorHtmlLike(ctr) {\n  if (typeof ctr === \"string\" || ctr === null) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isConstructorComponentClass(ctr) {\n  if (isConstructorHtmlLike(ctr)) {\n    return false;\n  }\n\n  if (ctr.prototype !== undefined && ctr.prototype instanceof Component) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isConstructorFunctionComponent(ctr) {\n  return typeof ctr === \"function\" && !isConstructorComponentClass(ctr);\n}\n\nfunction doesElementContainRootFiberNode(element) {\n  return element.hasOwnProperty(\"_reactRootContainer\") && element._reactRootContainer.hasOwnProperty(\"_internalRoot\");\n}\n\nfunction getRootFiberNodeFromDOM(startElement) {\n  var e_1, _a;\n\n  if (startElement === undefined) {\n    startElement = document.body;\n  }\n\n  if (doesElementContainRootFiberNode(startElement)) {\n    return startElement._reactRootContainer._internalRoot.current;\n  }\n\n  var returnFiberNode = null;\n\n  try {\n    for (var _b = __values([].slice.call(startElement.children)), _c = _b.next(); !_c.done; _c = _b.next()) {\n      var childNode = _c.value;\n      returnFiberNode = getRootFiberNodeFromDOM(childNode);\n\n      if (returnFiberNode !== null) {\n        return returnFiberNode;\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (_c && !_c.done && (_a = _b[\"return\"])) _a.call(_b);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  return returnFiberNode;\n}\n\nvar utils = /*#__PURE__*/Object.freeze({\n  isNodeHtmlLike: isNodeHtmlLike,\n  isNodeNotHtmlLike: isNodeNotHtmlLike,\n  isNodeFunctionComponent: isNodeFunctionComponent,\n  isNodeComponentClass: isNodeComponentClass,\n  isConstructorHtmlLike: isConstructorHtmlLike,\n  isConstructorComponentClass: isConstructorComponentClass,\n  isConstructorFunctionComponent: isConstructorFunctionComponent,\n  doesElementContainRootFiberNode: doesElementContainRootFiberNode,\n  getRootFiberNodeFromDOM: getRootFiberNodeFromDOM\n});\n\nfunction findNodeByComponentName(node, expectedName, traverseConfig) {\n  var e_1, _a;\n\n  if (node === null) {\n    return null;\n  }\n\n  var nodeIterator = traverseGenerator(node, traverseConfig);\n\n  try {\n    for (var nodeIterator_1 = __values(nodeIterator), nodeIterator_1_1 = nodeIterator_1.next(); !nodeIterator_1_1.done; nodeIterator_1_1 = nodeIterator_1.next()) {\n      var tmpNode = nodeIterator_1_1.value;\n\n      if (isNodeNotHtmlLike(tmpNode) && tmpNode.type.name === expectedName) {\n        return tmpNode;\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (nodeIterator_1_1 && !nodeIterator_1_1.done && (_a = nodeIterator_1[\"return\"])) _a.call(nodeIterator_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  return null;\n}\n\nfunction findNodeByComponent(node, expectedClassOrFunction, traverseConfig) {\n  var e_3, _a;\n\n  if (node === null) {\n    return null;\n  }\n\n  var nodeIterator = traverseGenerator(node, traverseConfig);\n\n  try {\n    for (var nodeIterator_3 = __values(nodeIterator), nodeIterator_3_1 = nodeIterator_3.next(); !nodeIterator_3_1.done; nodeIterator_3_1 = nodeIterator_3.next()) {\n      var tmpNode = nodeIterator_3_1.value;\n\n      if (isNodeNotHtmlLike(tmpNode) && tmpNode.type === expectedClassOrFunction) {\n        return tmpNode;\n      }\n    }\n  } catch (e_3_1) {\n    e_3 = {\n      error: e_3_1\n    };\n  } finally {\n    try {\n      if (nodeIterator_3_1 && !nodeIterator_3_1.done && (_a = nodeIterator_3[\"return\"])) _a.call(nodeIterator_3);\n    } finally {\n      if (e_3) throw e_3.error;\n    }\n  }\n\n  return null;\n}\n\nfunction findNodeByComponentRef(node, expectedClassInstance, traverseConfig) {\n  var e_4, _a;\n\n  if (node === null) {\n    return null;\n  }\n\n  var nodeIterator = traverseGenerator(node, traverseConfig);\n\n  try {\n    for (var nodeIterator_4 = __values(nodeIterator), nodeIterator_4_1 = nodeIterator_4.next(); !nodeIterator_4_1.done; nodeIterator_4_1 = nodeIterator_4.next()) {\n      var tmpNode = nodeIterator_4_1.value;\n\n      if (isNodeNotHtmlLike(tmpNode) && tmpNode.stateNode === expectedClassInstance) {\n        return tmpNode;\n      }\n    }\n  } catch (e_4_1) {\n    e_4 = {\n      error: e_4_1\n    };\n  } finally {\n    try {\n      if (nodeIterator_4_1 && !nodeIterator_4_1.done && (_a = nodeIterator_4[\"return\"])) _a.call(nodeIterator_4);\n    } finally {\n      if (e_4) throw e_4.error;\n    }\n  }\n\n  return null;\n}\n\nfunction matchGenerator(node, match) {\n  var matchParsed, selectorsCount, matchParsed_1, matchParsed_1_1, selectorParsed, e_1_1, parsedSelector, currentMatchingNodes, currentMatchingSelectorPartIndex, lastRelationshipSelectorPart, nextMatchingNodes, currentMatchingNodes_1, currentMatchingNodes_1_1, currentNode, currentMatchingSelectorPart, startParams, nextParams, traverseIterator, tmpNode, currentMatchingNodes_2, currentMatchingNodes_2_1, tmpNode, e_2_1;\n\n  var e_1, _a, e_3, _b, _c, e_2, _d;\n\n  return __generator(this, function (_e) {\n    switch (_e.label) {\n      case 0:\n        if (typeof match === \"string\") {\n          matchParsed = parse(match, {\n            lowerCaseTags: false,\n            lowerCaseAttributeNames: false\n          });\n        } else {\n          matchParsed = match;\n        }\n\n        selectorsCount = matchParsed.length;\n        if (!(selectorsCount > 1)) return [3, 9];\n        _e.label = 1;\n\n      case 1:\n        _e.trys.push([1, 6, 7, 8]);\n\n        matchParsed_1 = __values(matchParsed), matchParsed_1_1 = matchParsed_1.next();\n        _e.label = 2;\n\n      case 2:\n        if (!!matchParsed_1_1.done) return [3, 5];\n        selectorParsed = matchParsed_1_1.value;\n        return [5, __values(matchGenerator(node, [selectorParsed]))];\n\n      case 3:\n        _e.sent();\n\n        _e.label = 4;\n\n      case 4:\n        matchParsed_1_1 = matchParsed_1.next();\n        return [3, 2];\n\n      case 5:\n        return [3, 8];\n\n      case 6:\n        e_1_1 = _e.sent();\n        e_1 = {\n          error: e_1_1\n        };\n        return [3, 8];\n\n      case 7:\n        try {\n          if (matchParsed_1_1 && !matchParsed_1_1.done && (_a = matchParsed_1[\"return\"])) _a.call(matchParsed_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n\n        return [7];\n\n      case 8:\n        return [2];\n\n      case 9:\n        parsedSelector = matchParsed[0];\n\n        if (parsedSelector.length === 0) {\n          return [2];\n        }\n\n        currentMatchingNodes = [node];\n        currentMatchingSelectorPartIndex = 0;\n        lastRelationshipSelectorPart = undefined;\n\n        while (currentMatchingSelectorPartIndex < parsedSelector.length) {\n          nextMatchingNodes = [];\n\n          try {\n            for (currentMatchingNodes_1 = (e_3 = void 0, __values(currentMatchingNodes)), currentMatchingNodes_1_1 = currentMatchingNodes_1.next(); !currentMatchingNodes_1_1.done; currentMatchingNodes_1_1 = currentMatchingNodes_1.next()) {\n              currentNode = currentMatchingNodes_1_1.value;\n              currentMatchingSelectorPart = parsedSelector[currentMatchingSelectorPartIndex];\n\n              if ([\"tag\"].includes(currentMatchingSelectorPart.type)) {\n                startParams = {\n                  skipSelfForStartNode: true,\n                  skipSiblingForStartNode: true\n                };\n                nextParams = {};\n\n                if (lastRelationshipSelectorPart === undefined || lastRelationshipSelectorPart.type === \"descendant\") {\n                  nextParams = {\n                    skipChild: false,\n                    skipSibling: false\n                  };\n                } else if (lastRelationshipSelectorPart.type === \"child\") {\n                  nextParams = {\n                    skipChild: true\n                  };\n                } else if (lastRelationshipSelectorPart.type === \"sibling\") {\n                  nextParams = {\n                    skipChild: true,\n                    skipSibling: true\n                  };\n                  startParams.skipSiblingForStartNode = false;\n                }\n\n                traverseIterator = traverseGenerator(currentNode, startParams);\n\n                if (currentMatchingSelectorPart.type == \"tag\") {\n                  tmpNode = void 0;\n\n                  while (!(_c = traverseIterator.next(nextParams), tmpNode = _c.value, _c).done) {\n                    if (isNodeNotHtmlLike(tmpNode) && tmpNode.type.name === currentMatchingSelectorPart.name) {\n                      nextMatchingNodes.push(tmpNode);\n                    }\n                  }\n                }\n              } else if ([\"descendant\", \"child\"].includes(currentMatchingSelectorPart.type)) {\n                lastRelationshipSelectorPart = currentMatchingSelectorPart;\n                nextMatchingNodes.push.apply(nextMatchingNodes, __spread(currentMatchingNodes));\n              } else {\n                lastRelationshipSelectorPart = undefined;\n              }\n            }\n          } catch (e_3_1) {\n            e_3 = {\n              error: e_3_1\n            };\n          } finally {\n            try {\n              if (currentMatchingNodes_1_1 && !currentMatchingNodes_1_1.done && (_b = currentMatchingNodes_1[\"return\"])) _b.call(currentMatchingNodes_1);\n            } finally {\n              if (e_3) throw e_3.error;\n            }\n          }\n\n          currentMatchingNodes = nextMatchingNodes;\n          currentMatchingSelectorPartIndex += 1;\n        }\n\n        _e.label = 10;\n\n      case 10:\n        _e.trys.push([10, 15, 16, 17]);\n\n        currentMatchingNodes_2 = __values(currentMatchingNodes), currentMatchingNodes_2_1 = currentMatchingNodes_2.next();\n        _e.label = 11;\n\n      case 11:\n        if (!!currentMatchingNodes_2_1.done) return [3, 14];\n        tmpNode = currentMatchingNodes_2_1.value;\n        return [4, tmpNode];\n\n      case 12:\n        _e.sent();\n\n        _e.label = 13;\n\n      case 13:\n        currentMatchingNodes_2_1 = currentMatchingNodes_2.next();\n        return [3, 11];\n\n      case 14:\n        return [3, 17];\n\n      case 15:\n        e_2_1 = _e.sent();\n        e_2 = {\n          error: e_2_1\n        };\n        return [3, 17];\n\n      case 16:\n        try {\n          if (currentMatchingNodes_2_1 && !currentMatchingNodes_2_1.done && (_d = currentMatchingNodes_2[\"return\"])) _d.call(currentMatchingNodes_2);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n\n        return [7];\n\n      case 17:\n        return [2];\n    }\n  });\n}\n\nfunction matchAll(node, match) {\n  return __spread(matchGenerator(node, match));\n}\n\nfunction matchFirst(node, match) {\n  var matchIterator = matchGenerator(node, match);\n  var firstResult = matchIterator.next();\n  matchIterator[\"throw\"] && matchIterator[\"throw\"](new Error(\"Cleanup\"));\n\n  if (!firstResult.done) {\n    return firstResult.value;\n  }\n\n  return null;\n}\n\nexport { utils as Utils, findNodeByComponent, findNodeByComponentName, findNodeByComponentRef, matchAll, matchFirst, matchGenerator, traverse, traverseGenerator };","map":null,"metadata":{},"sourceType":"module"}