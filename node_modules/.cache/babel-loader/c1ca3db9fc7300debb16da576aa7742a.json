{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar react_1 = __importDefault(require(\"react\"));\n\nvar d3_hierarchy_1 = require(\"d3-hierarchy\");\n\nvar d3_selection_1 = require(\"d3-selection\");\n\nvar d3_zoom_1 = require(\"d3-zoom\");\n\nvar lite_1 = require(\"dequal/lite\");\n\nvar clone_1 = __importDefault(require(\"clone\"));\n\nvar uuid_1 = require(\"uuid\");\n\nvar TransitionGroupWrapper_1 = __importDefault(require(\"./TransitionGroupWrapper\"));\n\nvar Node_1 = __importDefault(require(\"../Node\"));\n\nvar Link_1 = __importDefault(require(\"../Link\"));\n\nvar globalCss_1 = __importDefault(require(\"../globalCss\"));\n\nvar Tree =\n/** @class */\nfunction (_super) {\n  __extends(Tree, _super);\n\n  function Tree() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      dataRef: _this.props.data,\n      data: Tree.assignInternalProperties(clone_1.default(_this.props.data)),\n      d3: Tree.calculateD3Geometry(_this.props),\n      isTransitioning: false,\n      isInitialRenderForDataset: true\n    };\n    _this.internalState = {\n      targetNode: null,\n      isTransitioning: false\n    };\n    _this.svgInstanceRef = \"rd3t-svg-\" + uuid_1.v4();\n    _this.gInstanceRef = \"rd3t-g-\" + uuid_1.v4();\n    /**\n     * Finds the node matching `nodeId` and\n     * expands/collapses it, depending on the current state of\n     * its internal `collapsed` property.\n     * `setState` callback receives targetNode and handles\n     * `props.onClick` if defined.\n     */\n\n    _this.handleNodeToggle = function (nodeId) {\n      var data = clone_1.default(_this.state.data);\n\n      var matches = _this.findNodesById(nodeId, data, []);\n\n      var targetNodeDatum = matches[0];\n\n      if (_this.props.collapsible && !_this.state.isTransitioning) {\n        if (targetNodeDatum.__rd3t.collapsed) {\n          Tree.expandNode(targetNodeDatum);\n          _this.props.shouldCollapseNeighborNodes && _this.collapseNeighborNodes(targetNodeDatum, data);\n        } else {\n          Tree.collapseNode(targetNodeDatum);\n        }\n\n        if (_this.props.enableLegacyTransitions) {\n          // Lock node toggling while transition takes place.\n          _this.setState({\n            data: data,\n            isTransitioning: true\n          }); // Await transitionDuration + 10 ms before unlocking node toggling again.\n\n\n          setTimeout(function () {\n            return _this.setState({\n              isTransitioning: false\n            });\n          }, _this.props.transitionDuration + 10);\n        } else {\n          _this.setState({\n            data: data\n          });\n        }\n\n        _this.internalState.targetNode = targetNodeDatum;\n      }\n    };\n    /**\n     * Handles the user-defined `onNodeClick` function.\n     */\n\n\n    _this.handleOnNodeClickCb = function (nodeId, evt) {\n      var onNodeClick = _this.props.onNodeClick;\n\n      if (onNodeClick && typeof onNodeClick === 'function') {\n        var data = clone_1.default(_this.state.data);\n\n        var matches = _this.findNodesById(nodeId, data, []);\n\n        var targetNode = matches[0]; // Persist the SyntheticEvent for downstream handling by users.\n\n        evt.persist();\n        onNodeClick(clone_1.default(targetNode), evt);\n      }\n    };\n    /**\n     * Handles the user-defined `onLinkClick` function.\n     */\n\n\n    _this.handleOnLinkClickCb = function (linkSource, linkTarget, evt) {\n      var onLinkClick = _this.props.onLinkClick;\n\n      if (onLinkClick && typeof onLinkClick === 'function') {\n        // Persist the SyntheticEvent for downstream handling by users.\n        evt.persist();\n        onLinkClick(clone_1.default(linkSource), clone_1.default(linkTarget), evt);\n      }\n    };\n    /**\n     * Handles the user-defined `onNodeMouseOver` function.\n     */\n\n\n    _this.handleOnNodeMouseOverCb = function (nodeId, evt) {\n      var onNodeMouseOver = _this.props.onNodeMouseOver;\n\n      if (onNodeMouseOver && typeof onNodeMouseOver === 'function') {\n        var data = clone_1.default(_this.state.data);\n\n        var matches = _this.findNodesById(nodeId, data, []);\n\n        var targetNode = matches[0]; // Persist the SyntheticEvent for downstream handling by users.\n\n        evt.persist();\n        onNodeMouseOver(clone_1.default(targetNode), evt);\n      }\n    };\n    /**\n     * Handles the user-defined `onLinkMouseOver` function.\n     */\n\n\n    _this.handleOnLinkMouseOverCb = function (linkSource, linkTarget, evt) {\n      var onLinkMouseOver = _this.props.onLinkMouseOver;\n\n      if (onLinkMouseOver && typeof onLinkMouseOver === 'function') {\n        // Persist the SyntheticEvent for downstream handling by users.\n        evt.persist();\n        onLinkMouseOver(clone_1.default(linkSource), clone_1.default(linkTarget), evt);\n      }\n    };\n    /**\n     * Handles the user-defined `onNodeMouseOut` function.\n     */\n\n\n    _this.handleOnNodeMouseOutCb = function (nodeId, evt) {\n      var onNodeMouseOut = _this.props.onNodeMouseOut;\n\n      if (onNodeMouseOut && typeof onNodeMouseOut === 'function') {\n        var data = clone_1.default(_this.state.data);\n\n        var matches = _this.findNodesById(nodeId, data, []);\n\n        var targetNode = matches[0]; // Persist the SyntheticEvent for downstream handling by users.\n\n        evt.persist();\n        onNodeMouseOut(clone_1.default(targetNode), evt);\n      }\n    };\n    /**\n     * Handles the user-defined `onLinkMouseOut` function.\n     */\n\n\n    _this.handleOnLinkMouseOutCb = function (linkSource, linkTarget, evt) {\n      var onLinkMouseOut = _this.props.onLinkMouseOut;\n\n      if (onLinkMouseOut && typeof onLinkMouseOut === 'function') {\n        // Persist the SyntheticEvent for downstream handling by users.\n        evt.persist();\n        onLinkMouseOut(clone_1.default(linkSource), clone_1.default(linkTarget), evt);\n      }\n    };\n    /**\n     * Determines which additional `className` prop should be passed to the node & returns it.\n     */\n\n\n    _this.getNodeClassName = function (parent, nodeDatum) {\n      var _a = _this.props,\n          rootNodeClassName = _a.rootNodeClassName,\n          branchNodeClassName = _a.branchNodeClassName,\n          leafNodeClassName = _a.leafNodeClassName;\n      var hasParent = parent !== null && parent !== undefined;\n\n      if (hasParent) {\n        return nodeDatum.children ? branchNodeClassName : leafNodeClassName;\n      } else {\n        return rootNodeClassName;\n      }\n    };\n\n    return _this;\n  }\n\n  Tree.getDerivedStateFromProps = function (nextProps, prevState) {\n    var derivedState = null; // Clone new data & assign internal properties if `data` object reference changed.\n\n    if (nextProps.data !== prevState.dataRef) {\n      derivedState = {\n        dataRef: nextProps.data,\n        data: Tree.assignInternalProperties(clone_1.default(nextProps.data)),\n        isInitialRenderForDataset: true\n      };\n    }\n\n    var d3 = Tree.calculateD3Geometry(nextProps);\n\n    if (!lite_1.dequal(d3, prevState.d3)) {\n      derivedState = derivedState || {};\n      derivedState.d3 = d3;\n    }\n\n    return derivedState;\n  };\n\n  Tree.prototype.componentDidMount = function () {\n    this.bindZoomListener(this.props);\n    this.setState({\n      isInitialRenderForDataset: false\n    });\n  };\n\n  Tree.prototype.componentDidUpdate = function (prevProps) {\n    if (this.props.data !== prevProps.data) {\n      // If last `render` was due to change in dataset -> mark the initial render as done.\n      this.setState({\n        isInitialRenderForDataset: false\n      });\n    }\n\n    if (!lite_1.dequal(this.props.translate, prevProps.translate) || !lite_1.dequal(this.props.scaleExtent, prevProps.scaleExtent) || this.props.zoom !== prevProps.zoom || this.props.enableLegacyTransitions !== prevProps.enableLegacyTransitions) {\n      // If zoom-specific props change -> rebind listener with new values.\n      // Or: rebind zoom listeners to new DOM nodes in case legacy transitions were enabled/disabled.\n      this.bindZoomListener(this.props);\n    }\n\n    if (typeof this.props.onUpdate === 'function') {\n      this.props.onUpdate({\n        node: this.internalState.targetNode ? clone_1.default(this.internalState.targetNode) : null,\n        zoom: this.state.d3.scale,\n        translate: this.state.d3.translate\n      });\n    } // Reset the last target node after we've flushed it to `onUpdate`.\n\n\n    this.internalState.targetNode = null;\n  };\n  /**\n   * Collapses all tree nodes with a `depth` larger than `initialDepth`.\n   *\n   * @param {array} nodeSet Array of nodes generated by `generateTree`\n   * @param {number} initialDepth Maximum initial depth the tree should render\n   */\n\n\n  Tree.prototype.setInitialTreeDepth = function (nodeSet, initialDepth) {\n    nodeSet.forEach(function (n) {\n      n.data.__rd3t.collapsed = n.depth >= initialDepth;\n    });\n  };\n  /**\n   * bindZoomListener - If `props.zoomable`, binds a listener for\n   * \"zoom\" events to the SVG and sets scaleExtent to min/max\n   * specified in `props.scaleExtent`.\n   */\n\n\n  Tree.prototype.bindZoomListener = function (props) {\n    var _this = this;\n\n    var zoomable = props.zoomable,\n        scaleExtent = props.scaleExtent,\n        translate = props.translate,\n        zoom = props.zoom,\n        onUpdate = props.onUpdate;\n    var svg = d3_selection_1.select(\".\" + this.svgInstanceRef);\n    var g = d3_selection_1.select(\".\" + this.gInstanceRef);\n\n    if (zoomable) {\n      // Sets initial offset, so that first pan and zoom does not jump back to default [0,0] coords.\n      // @ts-ignore\n      svg.call(d3_zoom_1.zoom().transform, d3_zoom_1.zoomIdentity.translate(translate.x, translate.y).scale(zoom));\n      svg.call(d3_zoom_1.zoom().scaleExtent([scaleExtent.min, scaleExtent.max]) // TODO: break this out into a separate zoom handler fn, rather than inlining it.\n      .on('zoom', function () {\n        g.attr('transform', d3_selection_1.event.transform);\n\n        if (typeof onUpdate === 'function') {\n          // This callback is magically called not only on \"zoom\", but on \"drag\", as well,\n          // even though event.type == \"zoom\".\n          // Taking advantage of this and not writing a \"drag\" handler.\n          onUpdate({\n            node: null,\n            zoom: d3_selection_1.event.transform.k,\n            translate: {\n              x: d3_selection_1.event.transform.x,\n              y: d3_selection_1.event.transform.y\n            }\n          }); // TODO: remove this? Shouldn't be mutating state keys directly.\n\n          _this.state.d3.scale = d3_selection_1.event.transform.k;\n          _this.state.d3.translate = {\n            x: d3_selection_1.event.transform.x,\n            y: d3_selection_1.event.transform.y\n          };\n        }\n      }));\n    }\n  };\n  /**\n   * Assigns internal properties that are required for tree\n   * manipulation to each node in the `data` set and returns a new `data` array.\n   *\n   * @static\n   */\n\n\n  Tree.assignInternalProperties = function (data, currentDepth) {\n    if (currentDepth === void 0) {\n      currentDepth = 0;\n    } // Wrap the root node into an array for recursive transformations if it wasn't in one already.\n\n\n    var d = Array.isArray(data) ? data : [data];\n    return d.map(function (n) {\n      var nodeDatum = n;\n      nodeDatum.__rd3t = {\n        id: null,\n        depth: null,\n        collapsed: false\n      };\n      nodeDatum.__rd3t.id = uuid_1.v4(); // D3@v5 compat: manually assign `depth` to node.data so we don't have\n      // to hold full node+link sets in state.\n      // TODO: avoid this extra step by checking D3's node.depth directly.\n\n      nodeDatum.__rd3t.depth = currentDepth; // If there are children, recursively assign properties to them too.\n\n      if (nodeDatum.children && nodeDatum.children.length > 0) {\n        nodeDatum.children = Tree.assignInternalProperties(nodeDatum.children, currentDepth + 1);\n      }\n\n      return nodeDatum;\n    });\n  };\n  /**\n   * Recursively walks the nested `nodeSet` until a node matching `nodeId` is found.\n   */\n\n\n  Tree.prototype.findNodesById = function (nodeId, nodeSet, hits) {\n    var _this = this;\n\n    if (hits.length > 0) {\n      return hits;\n    }\n\n    hits = hits.concat(nodeSet.filter(function (node) {\n      return node.__rd3t.id === nodeId;\n    }));\n    nodeSet.forEach(function (node) {\n      if (node.children && node.children.length > 0) {\n        hits = _this.findNodesById(nodeId, node.children, hits);\n      }\n    });\n    return hits;\n  };\n  /**\n   * Recursively walks the nested `nodeSet` until all nodes at `depth` have been found.\n   *\n   * @param {number} depth Target depth for which nodes should be returned\n   * @param {array} nodeSet Array of nested `node` objects\n   * @param {array} accumulator Accumulator for matches, passed between recursive calls\n   */\n\n\n  Tree.prototype.findNodesAtDepth = function (depth, nodeSet, accumulator) {\n    var _this = this;\n\n    accumulator = accumulator.concat(nodeSet.filter(function (node) {\n      return node.__rd3t.depth === depth;\n    }));\n    nodeSet.forEach(function (node) {\n      if (node.children && node.children.length > 0) {\n        accumulator = _this.findNodesAtDepth(depth, node.children, accumulator);\n      }\n    });\n    return accumulator;\n  };\n  /**\n   * Recursively sets the internal `collapsed` property of\n   * the passed `TreeNodeDatum` and its children to `true`.\n   *\n   * @static\n   */\n\n\n  Tree.collapseNode = function (nodeDatum) {\n    nodeDatum.__rd3t.collapsed = true;\n\n    if (nodeDatum.children && nodeDatum.children.length > 0) {\n      nodeDatum.children.forEach(function (child) {\n        Tree.collapseNode(child);\n      });\n    }\n  };\n  /**\n   * Sets the internal `collapsed` property of\n   * the passed `TreeNodeDatum` object to `false`.\n   *\n   * @static\n   */\n\n\n  Tree.expandNode = function (nodeDatum) {\n    nodeDatum.__rd3t.collapsed = false;\n  };\n  /**\n   * Collapses all nodes in `nodeSet` that are neighbors (same depth) of `targetNode`.\n   */\n\n\n  Tree.prototype.collapseNeighborNodes = function (targetNode, nodeSet) {\n    var neighbors = this.findNodesAtDepth(targetNode.__rd3t.depth, nodeSet, []).filter(function (node) {\n      return node.__rd3t.id !== targetNode.__rd3t.id;\n    });\n    neighbors.forEach(function (neighbor) {\n      return Tree.collapseNode(neighbor);\n    });\n  };\n  /**\n   * Generates tree elements (`nodes` and `links`) by\n   * grabbing the rootNode from `this.state.data[0]`.\n   * Restricts tree depth to `props.initialDepth` if defined and if this is\n   * the initial render of the tree.\n   */\n\n\n  Tree.prototype.generateTree = function () {\n    var _a = this.props,\n        initialDepth = _a.initialDepth,\n        depthFactor = _a.depthFactor,\n        separation = _a.separation,\n        nodeSize = _a.nodeSize,\n        orientation = _a.orientation;\n    var isInitialRenderForDataset = this.state.isInitialRenderForDataset;\n    var tree = d3_hierarchy_1.tree().nodeSize(orientation === 'horizontal' ? [nodeSize.y, nodeSize.x] : [nodeSize.x, nodeSize.y]).separation(function (a, b) {\n      return a.parent.data.__rd3t.id === b.parent.data.__rd3t.id ? separation.siblings : separation.nonSiblings;\n    });\n    var rootNode = tree(d3_hierarchy_1.hierarchy(this.state.data[0], function (d) {\n      return d.__rd3t.collapsed ? null : d.children;\n    }));\n    var nodes = rootNode.descendants();\n    var links = rootNode.links(); // Configure nodes' `collapsed` property on first render if `initialDepth` is defined.\n\n    if (initialDepth !== undefined && isInitialRenderForDataset) {\n      this.setInitialTreeDepth(nodes, initialDepth);\n    }\n\n    if (depthFactor) {\n      nodes.forEach(function (node) {\n        node.y = node.depth * depthFactor;\n      });\n    }\n\n    return {\n      nodes: nodes,\n      links: links\n    };\n  };\n  /**\n   * Set initial zoom and position.\n   * Also limit zoom level according to `scaleExtent` on initial display. This is necessary,\n   * because the first time we are setting it as an SVG property, instead of going\n   * through D3's scaling mechanism, which would have picked up both properties.\n   *\n   * @static\n   */\n\n\n  Tree.calculateD3Geometry = function (nextProps) {\n    var scale;\n\n    if (nextProps.zoom > nextProps.scaleExtent.max) {\n      scale = nextProps.scaleExtent.max;\n    } else if (nextProps.zoom < nextProps.scaleExtent.min) {\n      scale = nextProps.scaleExtent.min;\n    } else {\n      scale = nextProps.zoom;\n    }\n\n    return {\n      translate: nextProps.translate,\n      scale: scale\n    };\n  };\n\n  Tree.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.generateTree(),\n        nodes = _a.nodes,\n        links = _a.links;\n\n    var _b = this.props,\n        renderCustomNodeElement = _b.renderCustomNodeElement,\n        orientation = _b.orientation,\n        pathFunc = _b.pathFunc,\n        transitionDuration = _b.transitionDuration,\n        zoomable = _b.zoomable,\n        nodeSize = _b.nodeSize,\n        depthFactor = _b.depthFactor,\n        initialDepth = _b.initialDepth,\n        separation = _b.separation,\n        enableLegacyTransitions = _b.enableLegacyTransitions,\n        svgClassName = _b.svgClassName,\n        pathClassFunc = _b.pathClassFunc;\n    var _c = this.state.d3,\n        translate = _c.translate,\n        scale = _c.scale;\n\n    var subscriptions = __assign(__assign(__assign({}, nodeSize), separation), {\n      depthFactor: depthFactor,\n      initialDepth: initialDepth\n    });\n\n    return react_1.default.createElement(\"div\", {\n      className: \"rd3t-tree-container \" + (zoomable ? 'rd3t-grabbable' : undefined)\n    }, react_1.default.createElement(\"style\", null, globalCss_1.default), react_1.default.createElement(\"svg\", {\n      className: \"rd3t-svg \" + this.svgInstanceRef + \" \" + svgClassName,\n      width: \"100%\",\n      height: \"100%\"\n    }, react_1.default.createElement(TransitionGroupWrapper_1.default, {\n      enableLegacyTransitions: enableLegacyTransitions,\n      component: \"g\",\n      className: \"rd3t-g \" + this.gInstanceRef,\n      transform: \"translate(\" + translate.x + \",\" + translate.y + \") scale(\" + scale + \")\"\n    }, links.map(function (linkData, i) {\n      return react_1.default.createElement(Link_1.default, {\n        key: 'link-' + i,\n        orientation: orientation,\n        pathFunc: pathFunc,\n        pathClassFunc: pathClassFunc,\n        linkData: linkData,\n        onClick: _this.handleOnLinkClickCb,\n        onMouseOver: _this.handleOnLinkMouseOverCb,\n        onMouseOut: _this.handleOnLinkMouseOutCb,\n        enableLegacyTransitions: enableLegacyTransitions,\n        transitionDuration: transitionDuration\n      });\n    }), nodes.map(function (_a, i) {\n      var data = _a.data,\n          x = _a.x,\n          y = _a.y,\n          parent = _a.parent,\n          rest = __rest(_a, [\"data\", \"x\", \"y\", \"parent\"]);\n\n      return react_1.default.createElement(Node_1.default, {\n        key: 'node-' + i,\n        data: data,\n        position: {\n          x: x,\n          y: y\n        },\n        parent: parent,\n        nodeClassName: _this.getNodeClassName(parent, data),\n        renderCustomNodeElement: renderCustomNodeElement,\n        nodeSize: nodeSize,\n        orientation: orientation,\n        enableLegacyTransitions: enableLegacyTransitions,\n        transitionDuration: transitionDuration,\n        onNodeToggle: _this.handleNodeToggle,\n        onNodeClick: _this.handleOnNodeClickCb,\n        onNodeMouseOver: _this.handleOnNodeMouseOverCb,\n        onNodeMouseOut: _this.handleOnNodeMouseOutCb,\n        subscriptions: subscriptions\n      });\n    }))));\n  };\n\n  Tree.defaultProps = {\n    onNodeClick: undefined,\n    onNodeMouseOver: undefined,\n    onNodeMouseOut: undefined,\n    onLinkClick: undefined,\n    onLinkMouseOver: undefined,\n    onLinkMouseOut: undefined,\n    onUpdate: undefined,\n    orientation: 'horizontal',\n    translate: {\n      x: 0,\n      y: 0\n    },\n    pathFunc: 'diagonal',\n    pathClassFunc: undefined,\n    transitionDuration: 500,\n    depthFactor: undefined,\n    collapsible: true,\n    initialDepth: undefined,\n    zoomable: true,\n    zoom: 1,\n    scaleExtent: {\n      min: 0.1,\n      max: 1\n    },\n    nodeSize: {\n      x: 140,\n      y: 140\n    },\n    separation: {\n      siblings: 1,\n      nonSiblings: 2\n    },\n    shouldCollapseNeighborNodes: false,\n    svgClassName: '',\n    rootNodeClassName: '',\n    branchNodeClassName: '',\n    leafNodeClassName: '',\n    renderCustomNodeElement: undefined,\n    enableLegacyTransitions: false\n  };\n  return Tree;\n}(react_1.default.Component);\n\nexports.default = Tree;","map":null,"metadata":{},"sourceType":"script"}